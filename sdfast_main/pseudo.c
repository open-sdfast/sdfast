/* Copyright 2026 Michael Sherman
 * Copyright 1989-2025 PTC Inc.; 1984-1988 Symbolic Dynamics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code to generate the routines:
 *   sdpseudo      sdpsderiv
 * 
 * These routines calculate pseudo-coordinate for loop joints, using
 * data expected to have been generated by the generation of SDSTATE
 * (for sdpseudo) and SDRHS (for sdpsderiv).
 */

#include "sdfast.h"
#include "sdfaprot.h"
#include "sderror.h"

/* Lqx and lux are input expressions containing calculated loop q's and u's.
 */
void PRINT_SDPSEUDO(FILE *F,
               expr lqx,
               expr lux)
{
    int i;

    declare_proc(F, 0, "pseudo",
      VT_USER, &SysI.type_Arr_nlq, "lqout",
      VT_USER, &SysI.type_Arr_sl,  "luout",
      0);

    efprintf(F, "%{\n\
Return pseudo-coordinates for loop joints.\n\n");
    efprintf(F, "%}");

    if (SysI.nl == 0) {
        efprintf(F, "%{\n\
There are no loop joints in this system.\n\n");
        efprintf(F, "%}");
        efprintf(F, Lang->proc_sbegin);
        efprintf(F, Lang->proc_end);
        return;
    }

    efprintf(F, Lang->proc_dbegin);
    declare_sdginput_vars(F, DECL_NODSYM);
    declare_sdgtopo_vars(F, DECL_NODSYM);
    declare_sdgstate_vars(F, DECL_NODSYM);
    declare_sdglhs_vars(F, DECL_NODSYM);
    declare_sdgrhs_vars(F, DECL_NODSYM);
    declare_sdgtemp_vars(F, DECL_NODSYM);
    efprintf(F, Lang->proc_dend);

    efprintf(F, Lang->proc_sbegin);

    CHECK_STATE(F, ST_STATEREADY, ST_DERIVREADY, 
                ROU_sdpseudo, ERR_sdstateMustBeCalledFirst);

    for (i=0; i < SysI.nlq; i++)
        PRINT_ASSN1(F, "lqout", i, INDX(lqx,i));

    for (i=0; i < SysI.sl; i++)
        PRINT_ASSN1(F, "luout", i, INDX(lux,i));

    efprintf(F, Lang->proc_end);
}

/* Generate sdpsqdot() and sdpsudot().  These used to be in a single
 * routine, but that caused problems when using Dassl because the
 * qdot's are needed by Applied Motion to integrate loop q's, but 
 * sdresid() (which is used by Dassl) does not provide enough 
 * calculation to obtain the loop udots.
 */
void PRINT_SDPSDERIV(FILE *F,
                expr lqdotx, 
                expr ludotx)
{
    int i;

    declare_proc(F, 0, "psqdot",
      VT_USER, &SysI.type_Arr_nlq, "lqdout",
      0);

    efprintf(F, "%{\n\
Return pseudo-coordinate derivatives for loop joints.\n\n");
    efprintf(F, "%}");

    if (SysI.nl == 0) {
        efprintf(F, "%{\n\
There are no loop joints in this system.\n\n");
        efprintf(F, "%}");
        efprintf(F, Lang->proc_sbegin);
        efprintf(F, Lang->proc_end);
        goto do_psudot;
    }

    efprintf(F, Lang->proc_dbegin);
    declare_sdginput_vars(F, DECL_NODSYM);
    declare_sdgtopo_vars(F, DECL_NODSYM);
    declare_sdgstate_vars(F, DECL_NODSYM);
    declare_sdglhs_vars(F, DECL_NODSYM);
    declare_sdgrhs_vars(F, DECL_NODSYM);
    declare_sdgtemp_vars(F, DECL_NODSYM);
    efprintf(F, Lang->proc_dend);

    efprintf(F, Lang->proc_sbegin);

    CHECK_STATE(F, ST_STATEREADY, ST_DERIVREADY, 
                ROU_sdpsqdot, ERR_sdstateMustBeCalledFirst);

    for (i=0; i < SysI.nlq; i++)
        PRINT_ASSN1(F, "lqdout", i, INDX(lqdotx,i));

    efprintf(F, Lang->proc_end);

  do_psudot:

    declare_proc(F, 0, "psudot",
      VT_USER, &SysI.type_Arr_sl,  "ludout",
      0);

    efprintf(F, "%{\n\
Return pseudo-coordinate accelerations for loop joints.\n\n");
    efprintf(F, "%}");

    if (SysI.nl == 0) {
        efprintf(F, "%{\n\
There are no loop joints in this system.\n\n");
        efprintf(F, "%}");
        efprintf(F, Lang->proc_sbegin);
        efprintf(F, Lang->proc_end);
        return;
    }

    efprintf(F, Lang->proc_dbegin);
    declare_sdginput_vars(F, DECL_NODSYM);
    declare_sdgtopo_vars(F, DECL_NODSYM);
    declare_sdgstate_vars(F, DECL_NODSYM);
    declare_sdglhs_vars(F, DECL_NODSYM);
    declare_sdgrhs_vars(F, DECL_NODSYM);
    declare_sdgtemp_vars(F, DECL_NODSYM);
    efprintf(F, Lang->proc_dend);

    efprintf(F, Lang->proc_sbegin);

    CHECK_STATE(F, ST_DERIVREADY, ST_NOSTATE, 
                ROU_sdpsudot, ERR_sdderivMustBeCalledFirst);

    for (i=0; i < SysI.sl; i++)
        PRINT_ASSN1(F, "ludout", i, INDX(ludotx,i));

    efprintf(F, Lang->proc_end);
}

/* COMPUTE_Cibob
 * COMPUTE_Woiob
 *
 * Compute direction cosines Cibob giving relative orientation between the 
 * frames defined by (ipin,iref,iperp) on the inboard body (the `ib' frame) 
 * and (opin,oref,operp) on the outboard body (the `ob' frame).  Also, 
 * compute the angular velocity Woiob of the outboard body with respect
 * to the inboard body, expressed in the ob frame.
 *
 * How shall we accomplish these amazing feats?  Like this:
 *
 * Set
 *
 *    ib i   [ ipin   ]       o ob   [ o  o  o ]       (No sym's associated
 *      C  = [ iref   ]        C   = [ p  r  p ]        with these two.)
 *           [ iperp  ]              [ i  e  e ]
 *                                   [ n  f  r ]
 *                                   [       p ]
 *
 * In case of a ball joint, both Cibi and Coob are identity matrices.
 * For a 6dof joint, Cibi is as above but Coob is an identity matrix.
 *
 * i o
 *  C  must already have been computed.  Now, compute
 *
 *    ib o    ib i   i o
 *      C   =   C  *  C
 *
 *    ib ob   ib o   o ob
 *      C   =   C  *  C
 * 
 * Next, 
 *                          i o
 *    Woio = wk[o] - wk[i] * C
 *
 *                   o ob
 *    Woiob = Woio *  C
 *
 * Note: the order of computation below is different from the above
 * for convenience in flushing out the intermediate values Cibo and Woio.
 *
 * This is an Order(N) computation, with N=number of loop joints.
 */

/*
 * Compute Cibob -- see above. 
 */
void COMPUTE_Cibob(FILE *F)
{
    int i,k;
    expr Cibix, Coobx, Cibox, Cibobx;

    Cibox  = INUSE(NEW_1dARRAY(cMatrixVal, SysI.nl));
    Cibobx = INUSE(NEW_1dARRAY(cMatrixVal, SysI.nl));

    /* First compute Cibo and flush it out. */
    for (k = 0; k < SysI.nl; k++) {
        if (SysI.LoopConst[k].jnt.JointKind == cBallJoint)
            Cibix = MATRIX_IDENT();
        else {
            Cibix = INUSE(NEW_MATX(cScalarVal));
            for (i=0; i<3; i++) {
                SINDX2(Cibix, 0, i, INDX(VAL1(ipin,k), i));
                SINDX2(Cibix, 1, i, INDX(VAL1(iref,k), i));
                SINDX2(Cibix, 2, i, INDX(VAL1(iperp,k), i));
            }
        }

        SINDX(Cibox, k, MATMUL(Cibix, VAL1(Cio,k)));
        DISPOSE_EXPR(UNUSE(Cibix));
    }
    ASSIGN_CLN(F, Cibo, UNUSE(Cibox));

    /* Now compute Cibob. */
    for (k = 0; k < SysI.nl; k++) {
        if (SysI.LoopConst[k].jnt.JointKind == cBallJoint
                 || SysI.LoopConst[k].jnt.JointKind == c6dJoint)
            Coobx = MATRIX_IDENT();
        else {
            Coobx = INUSE(NEW_MATX(cScalarVal));
            for (i=0; i<3; i++) {
                SINDX2(Coobx, i, 0, INDX(VAL1(opin,k), i));
                SINDX2(Coobx, i, 1, INDX(VAL1(oref,k), i));
                SINDX2(Coobx, i, 2, INDX(VAL1(operp,k), i));
            }
        }

        SINDX(Cibobx, k, MATMUL(VAL1(Cibo, k), Coobx));
        DISPOSE_EXPR(UNUSE(Coobx));
    }

    ASSIGN_CLN(F, Cibob, UNUSE(Cibobx));
}

/*
 * Compute Woiob -- see above. 
 */
void COMPUTE_Woiob(FILE *F)
{
    int inb,outb,i,k,ip,op;
    expr Coobx, Woiox, Woiobx;

    Woiox  = INUSE(NEW_1dARRAY(cVectorVal, SysI.nl));
    Woiobx = INUSE(NEW_1dARRAY(cVectorVal, SysI.nl));

    /* First compute Woio and flush it out. */
    for (k = 0; k < SysI.nl; k++) {
        inb = SysI.LoopConst[k].jnt.InbBody;
        outb = SysI.LoopConst[k].jnt.OutbBody;
        /* get pseudo-body numbers for inb and outb */
        if (!rbod_is_gnd(inb))
            ip = SysI.LastDOF[inb];        
        if (!rbod_is_gnd(outb))
            op = SysI.LastDOF[outb];

        SINDX(Woiox, k, 
            SUB(rbod_is_gnd(outb) ? VECTOR_ZERO() : VAL1(wk, op),
                MATMUL(rbod_is_gnd(inb) ? VECTOR_ZERO() : VAL1(wk, ip), 
                       VAL1(Cio,k))));
    }
    ASSIGN_CLN(F, Woio, UNUSE(Woiox));

    /* Now compute Woiob. */
    for (k = 0; k < SysI.nl; k++) {
        if (SysI.LoopConst[k].jnt.JointKind == cBallJoint
                 || SysI.LoopConst[k].jnt.JointKind == c6dJoint)
            Coobx = MATRIX_IDENT();
        else {
            Coobx = INUSE(NEW_MATX(cScalarVal));
            for (i=0; i<3; i++) {
                SINDX2(Coobx, i, 0, INDX(VAL1(opin,k), i));
                SINDX2(Coobx, i, 1, INDX(VAL1(oref,k), i));
                SINDX2(Coobx, i, 2, INDX(VAL1(operp,k), i));
            }
        }

        SINDX(Woiobx, k, MATMUL(VAL1(Woio, k), Coobx));
    }

    ASSIGN_CLN(F, Woiob, UNUSE(Woiobx));
}

/* COMPUTE_Ooiob
 *
 * Compute the angular acceleration of the outboard body with respect to
 * the inboard body, expressed in the ob frame.  This is needed for all
 * loop joints except sliders, in the computation of loop joint udots.
 *
 * The formulae are:
 *
 *       Ooiob[k][0] = (onk[o] - onk[i]*Cio) * opin[k]
 *                     + Woio[k] * (wk[o] X opin[k])
 *       Ooiob[k][0] = (onk[o] - onk[i]*Cio) * oref[k]
 *                     + Woio[k] * (wk[o] X oref[k])
 *       Ooiob[k][0] = (onk[o] - onk[i]*Cio) * operp[k]
 *                     + Woio[k] * (wk[o] X operp[k])
 *
 * We already have vt3[k]   = wk[o] X opin[k]
 *                 vt10a[k] = wk[o] X oref[k]
 *                 vt13a[k] = wk[o] X operp[k]
 *                    vt24[k]  = onk[o] - onk[i]*Cio
 *
 * For ball and 6dof joints (which have no pins),
 *
 *      Ooiob[k] = onk[o] - onk[i]*Cio - (wk[i]*Cio X wk[o])
 *
 *         More convenient, since Woio[k]=wk[o]-wk[i]*Cio, this is
 *
 *      Ooiob[k] = onk[o] - onk[i]*Cio + (Woio[k] X wk[o])
 *       
 *
 * This is an Order(N) computation, with N=number of loop joints.
 */
void COMPUTE_Ooiob(FILE *F)
{
    int k,outb,op;
    expr Ooiobx,temp;

    Ooiobx = INUSE(NEW_1dARRAY(cVectorVal, SysI.nl));

    for (k = 0; k < SysI.nl; k++) {
        outb = SysI.LoopConst[k].jnt.OutbBody;
        /* get pseudo-body number for outb */
        if (!rbod_is_gnd(outb))
            op = SysI.LastDOF[outb];

        switch(SysI.LoopConst[k].jnt.JointKind) {
            case cSlidingJoint:
            case cWeldJoint:
                /* no rotations */
                SINDX(Ooiobx, k, VECTOR_ZERO());
                break;

            case cBallJoint:
            case c6dJoint:
                /* no rotational axes, just use relative angular
                   accelerations of the bodies */
                SINDX(Ooiobx, k, ADD(VAL1(vt24, k),
                                     CROSS(VAL1(Woio,k), 
                                           rbod_is_gnd(outb) ? VECTOR_ZERO()
                                                             : VAL1(wk,op))));
                break;

            default:
                /* transform angular acceleration to ob frame */
                temp = NEW_VECX(cScalarVal);
                SINDX(temp, 0, ADD(DOT(VAL1(vt24,k), VAL1(opin,k)),
                                   DOT(VAL1(Woio,k), VAL1(vt3,k))));
                SINDX(temp, 1, ADD(DOT(VAL1(vt24,k), VAL1(oref,k)),
                                   DOT(VAL1(Woio,k), VAL1(vt10a,k))));
                SINDX(temp, 2, ADD(DOT(VAL1(vt24,k), VAL1(operp,k)),
                                   DOT(VAL1(Woio,k), VAL1(vt13a,k))));
                SINDX(Ooiobx, k, temp);
                break;
        }
    }

    ASSIGN_CLN(F, Ooiob, UNUSE(Ooiobx));
}

/* COMPUTE_euler
 *
 * For loop joints including rotational pins, we need Euler angles going from 
 * the `ib' frame to the `ob' frame (see above).  For u's these
 * are 1-3-1 Euler angles (sort of), for gimbals they are, well, gimbal angles
 * (different Euler sequences depending on construction) otherwise they are 
 * 1-2-3 angles.  For ball joints we need 4 Euler parameters instead.  For 
 * sliders, we need the distance moved along the axis (the inboard body's axis,
 * if there is misalignment).  A joint consisting of only a slider does not 
 * require any euler computation.
 *
 * The direction cosine for loop joint i is found in Cibob[i], and
 * the corresponding Euler angles (or parameters) are left in eul1, eul2, 
 * eul3, and eul4, which will have been assigned and cleaned on return.
 * For joints with sliders, the distance along each of the sliding directions 
 * is returned in sli1, sli2, and sli3.  Only those sliding directions
 * that are needed by the joint are returned, the others will be set to
 * zero.
 *
 * Various already-declared symbols are passed in here and used by lower
 * level routines as temporaries.  The variable `temp' will be used liberally
 * as well.  If there are gimbal joints, the corresponding
 * elements of pin2x will be set to the current orientation of the vector
 * attached to the first intermediate gimbal frame which is coincident with
 * ipin2 in the configuration where the first gimbal angle is 0.  This is 
 * used later by the routines which compute the gimbal hinge velocities and
 * accelerations.
 */
void COMPUTE_euler(FILE *F,
              sym tmp1,
              sym  tmp2,
              sym  tmp3,
              sym  tmpv1,
              sym  tmpv2,
              sym  tmpv3,
              sym  e1,
              sym  e2,
              sym  e3,
              sym  e4,
              sym  pin2x)
{
    expr eul1x, eul2x, eul3x, eul4x, e1x, e2x, e3x, e4x;
    expr sli1x, sli2x, sli3x;
    expr ceul1x, ceul2x, ceul3x, seul1x, seul2x, seul3x, tmpx;
    expr pin2x_x;
    int  i,j;
    JointKind_t jk;

    pin2x_x = INUSE(NEW_1dARRAY(cVectorVal,SysI.nl));
    /* not all of pin2x will be set, so initialize to innocuous values */
    for (i=0; i < SysI.nl; i++)
        SINDX(pin2x_x, i, VECTOR_ZERO());

    /* First handle the orientation variables. */

    eul1x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul2x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul3x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul4x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cWeldJoint:        
            case cSlidingJoint: 
                e1x = e2x = e3x = e4x = SCALAR_ZERO();
                break;

            case cPinJoint:
            case cCylJoint:
            case cPlanarJoint:
                DECOMPOSE_123(F, VAL1(Cibob,i), e1, e2, e3, &e1x, &e2x, &e3x);
                e4x = SCALAR_ZERO();
                break;

            case cUjoint:
                DECOMPOSE_UJOINT(F, VAL1(Cibob,i), tmp1, tmp2,
                                 e1, e2, e3, tmp3, &e1x, &e2x, &e3x);
                e4x = SCALAR_ZERO();
                break;

            case c3dJoint:
            case cBearingJoint:
            case cBushingJoint:
                DECOMPOSE_GIMBAL(F, i, tmp1, tmp2, tmp3, e1, e2, e3, 
                                 tmpv1, tmpv2, tmpv3, &e1x, &e2x, &e3x);
                /* tmpv3 is returned set to pin2x */
                tmpx = INUSE(NEW_VECX(cScalarVal));
                for (j=0; j<3; j++)
                    if (IS_CONST(VAL1(tmpv3,j)))
                        SINDX(tmpx,j,VAL1(tmpv3,j));
                    else {
                        PRINT_ASSN2(F, PRINTNAME(pin2x), i, j, VAL1(tmpv3,j));
                        SINDX(tmpx,j,INDX(VREF1(pin2x,i),j));
                    }
                SINDX(pin2x_x, i, UNUSE(tmpx));
                e4x = SCALAR_ZERO();
                break;

            case cBallJoint:
            case c6dJoint:
                DECOMPOSE_QUAT(F, VAL1(Cibob,i), tmp1,
                               e1, e2, e3, e4, &e1x, &e2x, &e3x, &e4x);
                SINDX(eul1x, i, e1x);
                SINDX(eul2x, i, e2x);
                SINDX(eul3x, i, e3x);
                SINDX(eul4x, i, e4x);
                break;

            default:
                fatal("COMPUTE_euler: unrecognized joint type");
                /*NOTREACHED*/
        }
        /* Must flush out the returned expressions now before any
           of the temps get reused. */
        if (IS_CONST(e1x)) 
            SINDX(eul1x, i, e1x);
        else {
            PRINT_ASSN1(F, PRINTNAME(eul1), i, e1x);
            DISPOSE_EXPR(e1x);
            SINDX(eul1x, i, VREF1(eul1, i));
        }
        if (IS_CONST(e2x)) 
            SINDX(eul2x, i, e2x);
        else {
            PRINT_ASSN1(F, PRINTNAME(eul2), i, e2x);
            DISPOSE_EXPR(e2x);
            SINDX(eul2x, i, VREF1(eul2, i));
        }
        if (IS_CONST(e3x)) 
            SINDX(eul3x, i, e3x);
        else {
            PRINT_ASSN1(F, PRINTNAME(eul3), i, e3x);
            DISPOSE_EXPR(e3x);
            SINDX(eul3x, i, VREF1(eul3, i));
        }
        if (IS_CONST(e4x)) 
            SINDX(eul4x, i, e4x);
        else {
            PRINT_ASSN1(F, PRINTNAME(eul4), i, e4x);
            DISPOSE_EXPR(e4x);
            SINDX(eul4x, i, VREF1(eul4, i));
        }

    }

    /* Anything in pin2x that needed cleaning was cleaned above. */
    ASSIGN(pin2x, UNUSE(pin2x_x));

    ASSIGN_CLN(F, eul1, UNUSE(eul1x));
    ASSIGN_CLN(F, eul2, UNUSE(eul2x));
    ASSIGN_CLN(F, eul3, UNUSE(eul3x));
    ASSIGN_CLN(F, eul4, UNUSE(eul4x));

    /* Now compute sines and cosines of all the Euler angles. */
    ceul1x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    ceul2x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    ceul3x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    seul1x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    seul2x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    seul3x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    for (i=0; i < SysI.nl; i++) {
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cPinJoint:
            case cCylJoint:
            case cPlanarJoint:
            case cUjoint:
            case c3dJoint:
            case cBearingJoint:
            case cBushingJoint:
                SINDX(ceul1x, i, COSINE(VAL1(eul1,i)));
                SINDX(ceul2x, i, COSINE(VAL1(eul2,i)));
                SINDX(ceul3x, i, COSINE(VAL1(eul3,i)));
                SINDX(seul1x, i, SINE(VAL1(eul1,i)));
                SINDX(seul2x, i, SINE(VAL1(eul2,i)));
                SINDX(seul3x, i, SINE(VAL1(eul3,i)));
                break;

            default:
                SINDX(ceul1x, i, SCALAR_ZERO());
                SINDX(ceul2x, i, SCALAR_ZERO());
                SINDX(ceul3x, i, SCALAR_ZERO());
                SINDX(seul1x, i, SCALAR_ZERO());
                SINDX(seul2x, i, SCALAR_ZERO());
                SINDX(seul3x, i, SCALAR_ZERO());
                break;
        }
    }

    ASSIGN_CLN(F, ceul1, UNUSE(ceul1x));
    ASSIGN_CLN(F, ceul2, UNUSE(ceul2x));
    ASSIGN_CLN(F, ceul3, UNUSE(ceul3x));
    ASSIGN_CLN(F, seul1, UNUSE(seul1x));
    ASSIGN_CLN(F, seul2, UNUSE(seul2x));
    ASSIGN_CLN(F, seul3, UNUSE(seul3x));

    /* done with orientations, now lets do translations */

    sli1x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli2x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli3x = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        jk = SysI.LoopConst[i].jnt.JointKind;
        switch(jk) {
            case cWeldJoint:        
            case cPinJoint:
            case cUjoint:
            case c3dJoint:
            case cBallJoint:
                /* no translations */
                SINDX(sli1x, i, SCALAR_ZERO());
                SINDX(sli2x, i, SCALAR_ZERO());
                SINDX(sli3x, i, SCALAR_ZERO());
                break;

            case cSlidingJoint: 
            case cCylJoint:
            case cBearingJoint:
                /* one translation */
                SINDX(sli1x, i, 
                    NEG(DOT(VAL1(vt11,i),VAL1(ipin,i))));
                SINDX(sli2x, i, SCALAR_ZERO());
                SINDX(sli3x, i, SCALAR_ZERO());
                break;

            case cPlanarJoint:
                /* two translations */
                SINDX(sli1x, i,
                    NEG(DOT(VAL1(vt11,i),VAL1(iref,i))));
                SINDX(sli2x, i,
                    NEG(DOT(VAL1(vt11,i),VAL1(iperp,i))));
                SINDX(sli3x, i, SCALAR_ZERO()); 
                break;

            case c6dJoint:
            case cBushingJoint:
                /* three translations */
                SINDX(sli1x, i, 
                    NEG(DOT(VAL1(vt11,i),VAL1(ipin,i))));
                SINDX(sli2x, i,
                    NEG(DOT(VAL1(vt11,i),VAL1(jk==c6dJoint?iref:ipin2,i))));
                SINDX(sli3x, i,
                    NEG(DOT(VAL1(vt11,i),VAL1(iperp,i))));
                break;

            default:
                fatal("COMPUTE_euler: unrecognized joint type");
                /*NOTREACHED*/
        }
    }

    ASSIGN_CLN(F, sli1, UNUSE(sli1x));
    ASSIGN_CLN(F, sli2, UNUSE(sli2x));
    ASSIGN_CLN(F, sli3, UNUSE(sli3x));
}

/* COMPUTE_euldot
 *
 * For loop joints including rotational pins, we compute the derivatives of
 * the Euler angles or Euler parameters computed in COMPUTE_euler above.
 * Answers are in eul1dot, etc., which have been assigned and cleaned on
 * output.  Sliding velocities are computed here as well, with answers in
 * sli1v, etc.
 *
 * We use the angular velocity of the ob frame relative to the ib frame,
 * which is already available in Woiob, and the sines and cosines of
 * Euler angles which can be found in seul1, ceul1, etc.
 *
 * For sliders we compute the derivatives of the translations along
 * the sliding axes.  We don't compute translations along other directions,
 * although there could be some, since we don't need to know.
 *
 * Ipin2x has already been filled in and will be used if there are any
 * loop gimbal joints.  (See COMPUTE_euler above.)
 */
void COMPUTE_euldot(FILE *F,
               sym pin2x,
               sym  tmp1,
               sym tmp2,
               sym tmp3,
               sym tmpv1,
               sym tmpv2,
               sym tmpv3)
{
    expr eul1dotx, eul2dotx, eul3dotx, eul4dotx;
    expr sli1vx, sli2vx, sli3vx, e1, e2, e3;
    JointKind_t jk;
    int  i;

    /* First handle Euler derivatives. */

    eul1dotx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul2dotx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul3dotx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul4dotx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cSlidingJoint: 
            case cWeldJoint:        
                SINDX(eul1dotx, i, SCALAR_ZERO());
                SINDX(eul2dotx, i, SCALAR_ZERO());
                SINDX(eul3dotx, i, SCALAR_ZERO());
                SINDX(eul4dotx, i, SCALAR_ZERO());
                break;

            case cPinJoint:
            case cCylJoint:
            case cPlanarJoint:
                SINDX(eul1dotx, i, 
                    DVD(SUB(MUL(INDX(VAL1(Woiob,i),0),VAL1(ceul3,i)),
                            MUL(INDX(VAL1(Woiob,i),1),VAL1(seul3,i))),
                        QUES(NEARTO(VAL1(ceul2,i),SCALAR_ZERO(),cNearZero),
                             QUES(LESSTHAN(VAL1(ceul2,i),SCALAR_ZERO()),
                                  SC(-cNearZero),
                                  SC(cNearZero)),
                             VAL1(ceul2,i))));
                if (!IS_SIMPLE(INDX(eul1dotx, i))) {
                    PRINT_ASSN1(F, PRINTNAME(eul1dot), i, INDX(eul1dotx,i));
                    SINDX(eul1dotx, i, VREF1(eul1dot, i));
                }

                SINDX(eul2dotx, i,
                    ADD(MUL(INDX(VAL1(Woiob,i),0),VAL1(seul3,i)),
                        MUL(INDX(VAL1(Woiob,i),1),VAL1(ceul3,i))));

                SINDX(eul3dotx, i,
                    SUB(INDX(VAL1(Woiob,i),2),
                        MUL(INDX(eul1dotx,i),VAL1(seul2,i))));

                SINDX(eul4dotx, i, SCALAR_ZERO());
                break;

            case cUjoint:
                SINDX(eul1dotx, i, 
                    NEG(DVD(SUB(MUL(INDX(VAL1(Woiob,i),2),VAL1(seul3,i)),
                                MUL(INDX(VAL1(Woiob,i),1),VAL1(ceul3,i))),
                            QUES(NEARTO(VAL1(seul2,i),SCALAR_ZERO(),cNearZero),
                                 QUES(LESSTHAN(VAL1(seul2,i),SCALAR_ZERO()),
                                      SC(-cNearZero),
                                      SC(cNearZero)),
                                 VAL1(seul2,i)))));
                if (!IS_SIMPLE(INDX(eul1dotx, i))) {
                    PRINT_ASSN1(F, PRINTNAME(eul1dot), i, INDX(eul1dotx,i));
                    SINDX(eul1dotx, i, VREF1(eul1dot, i));
                }

                SINDX(eul2dotx, i,
                    ADD(MUL(INDX(VAL1(Woiob,i),1),VAL1(seul3,i)),
                        MUL(INDX(VAL1(Woiob,i),2),VAL1(ceul3,i))));

                SINDX(eul3dotx, i,
                    SUB(INDX(VAL1(Woiob,i),0),
                        MUL(INDX(eul1dotx,i),VAL1(ceul2,i))));

                SINDX(eul4dotx, i, SCALAR_ZERO());
                break;

            case c3dJoint:
            case cBearingJoint:
            case cBushingJoint:
                GIMBAL_DOT(F, i, pin2x, tmp1, tmp2, tmp3, tmpv1, tmpv2, tmpv3, 
                           &e1, &e2, &e3);
                if (!IS_CONST(e1)) {
                    PRINT_ASSN1(F, PRINTNAME(eul1dot), i, e1);
                    DISPOSE_EXPR(e1);
                    e1 = VREF1(eul1dot, i);
                }
                if (!IS_CONST(e2)) {
                    PRINT_ASSN1(F, PRINTNAME(eul2dot), i, e2);
                    DISPOSE_EXPR(e2);
                    e2 = VREF1(eul2dot, i);
                }
                if (!IS_CONST(e3)) {
                    PRINT_ASSN1(F, PRINTNAME(eul3dot), i, e3);
                    DISPOSE_EXPR(e3);
                    e3 = VREF1(eul3dot, i);
                }
                SINDX(eul1dotx, i, e1);
                SINDX(eul2dotx, i, e2);
                SINDX(eul3dotx, i, e3);
                SINDX(eul4dotx, i, SCALAR_ZERO());
                break;

            case cBallJoint:
            case c6dJoint:
                SINDX(eul1dotx, i,
                    MUL(SC(0.5),
                        ADD(MUL(    VAL1(eul4,i),  INDX(VAL1(Woiob,i),0)),
                        ADD(MUL(NEG(VAL1(eul3,i)), INDX(VAL1(Woiob,i),1)),
                            MUL(    VAL1(eul2,i),  INDX(VAL1(Woiob,i),2))))));

                SINDX(eul2dotx, i,
                    MUL(SC(0.5),
                        ADD(MUL(    VAL1(eul3,i),  INDX(VAL1(Woiob,i),0)),
                        ADD(MUL(    VAL1(eul4,i),  INDX(VAL1(Woiob,i),1)),
                            MUL(NEG(VAL1(eul1,i)), INDX(VAL1(Woiob,i),2))))));

                SINDX(eul3dotx, i,
                    MUL(SC(0.5),
                        ADD(MUL(NEG(VAL1(eul2,i)), INDX(VAL1(Woiob,i),0)),
                        ADD(MUL(    VAL1(eul1,i),  INDX(VAL1(Woiob,i),1)),
                            MUL(    VAL1(eul4,i),  INDX(VAL1(Woiob,i),2))))));

                SINDX(eul4dotx, i,
                    MUL(SC(-0.5),
                        ADD(MUL(    VAL1(eul1,i),  INDX(VAL1(Woiob,i),0)),
                        ADD(MUL(    VAL1(eul2,i),  INDX(VAL1(Woiob,i),1)),
                            MUL(    VAL1(eul3,i),  INDX(VAL1(Woiob,i),2))))));
                break;

            default:
                fatal("COMPUTE_euldot: unrecognized joint type");
                /*NOTREACHED*/
        }
    }

    ASSIGN_CLN(F, eul1dot, UNUSE(eul1dotx));
    ASSIGN_CLN(F, eul2dot, UNUSE(eul2dotx));
    ASSIGN_CLN(F, eul3dot, UNUSE(eul3dotx));
    ASSIGN_CLN(F, eul4dot, UNUSE(eul4dotx));

    /* Now handle translational derivatives. */

    sli1vx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli2vx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli3vx = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        jk = SysI.LoopConst[i].jnt.JointKind;
        switch(jk) {
            case cWeldJoint:        
            case cPinJoint:
            case cUjoint:
            case c3dJoint:
            case cBallJoint:
                /* no translations */
                SINDX(sli1vx, i, SCALAR_ZERO());
                SINDX(sli2vx, i, SCALAR_ZERO());
                SINDX(sli3vx, i, SCALAR_ZERO());
                break;

            case cSlidingJoint: 
            case cCylJoint:
            case cBearingJoint:
                /* one translation */
                SINDX(sli1vx, i,
                    NEG(ADD(DOT(VAL1(vt12,i),VAL1(ipin,i)),
                            DOT(VAL1(vt13,i),VAL1(vt11,i)))));
                SINDX(sli2vx, i, SCALAR_ZERO());
                SINDX(sli3vx, i, SCALAR_ZERO());
                break;

            case cPlanarJoint:
                /* two translations */
                SINDX(sli1vx, i, 
                    NEG(ADD(DOT(VAL1(vt12,i),VAL1(iref,i)),
                            DOT(VAL1(vt2,i),VAL1(vt11,i)))));
                SINDX(sli2vx, i, 
                    NEG(ADD(DOT(VAL1(vt12,i),VAL1(iperp,i)),
                            DOT(VAL1(vt5,i),VAL1(vt11,i)))));
                SINDX(sli3vx, i, SCALAR_ZERO());
                break;

            case c6dJoint:
            case cBushingJoint:
                /* three translations */
                SINDX(sli1vx, i,
                    NEG(ADD(DOT(VAL1(vt12,i),VAL1(ipin,i)),
                            DOT(VAL1(vt13,i),VAL1(vt11,i)))));

                if (jk == c6dJoint)
                    SINDX(sli2vx, i, 
                        NEG(ADD(DOT(VAL1(vt12,i),VAL1(iref,i)),
                                DOT(VAL1(vt2,i),VAL1(vt11,i)))));
                else 
                    SINDX(sli2vx, i, 
                        NEG(ADD(DOT(VAL1(vt12,i),VAL1(ipin2,i)),
                                DOT(VAL1(vt2a,i),VAL1(vt11,i)))));

                SINDX(sli3vx, i, 
                    NEG(ADD(DOT(VAL1(vt12,i),VAL1(iperp,i)),
                            DOT(VAL1(vt5,i),VAL1(vt11,i)))));
                break;

            default:
                fatal("COMPUTE_euldot: unrecognized joint type");
                /*NOTREACHED*/
        }
    }

    ASSIGN_CLN(F, sli1v, UNUSE(sli1vx));
    ASSIGN_CLN(F, sli2v, UNUSE(sli2vx));
    ASSIGN_CLN(F, sli3v, UNUSE(sli3vx));
}

/* COMPUTE_eulacc
 *
 * For loop joints including rotational pins, we compute the second 
 * derivatives of the Euler angles.  For balls, we compute the derivative
 * of the angular velocity.  For sliders, we compute the derivative of the
 * linear velocity.  We don't bother computing acceleration components
 * that we won't need to report.
 *
 * Answers are in eul1a, sli1a, etc., which have been assigned and cleaned on
 * output.  
 *
 * We use most all the goodies that were computed above.
 */
void COMPUTE_eulacc(FILE *F,
               sym pin2x,
               sym tmp1,
               sym tmp2,
               sym tmpv1,
               sym tmpv2,
               sym tmpv3,
               sym tmpv4,
               sym tmpv5)
{
    expr eul1ax, eul2ax, eul3ax;
    expr sli1ax, sli2ax, sli3ax;
    expr e1dd,e2dd,e3dd;
    JointKind_t jk;
    int  i;

    /* First handle rotational stuff. */

    eul1ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul2ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    eul3ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cSlidingJoint: 
            case cWeldJoint:        
                SINDX(eul1ax, i, SCALAR_ZERO());
                SINDX(eul2ax, i, SCALAR_ZERO());
                SINDX(eul3ax, i, SCALAR_ZERO());
                break;

            case cPinJoint:
            case cCylJoint:
            case cPlanarJoint:
                SINDX(eul1ax, i, 
                    DVD(SUB(SUB(MUL(INDX(VAL1(Ooiob,i),0),VAL1(ceul3,i)),
                                MUL(INDX(VAL1(Ooiob,i),1),VAL1(seul3,i))),
                            ADD(MUL(VAL1(eul2dot,i),VAL1(eul3dot,i)),
                                MUL(VAL1(eul1dot,i),
                                    MUL(VAL1(seul2,i),VAL1(eul2dot,i))))),
                        QUES(NEARTO(VAL1(ceul2,i),SCALAR_ZERO(),cNearZero),
                             QUES(LESSTHAN(VAL1(ceul2,i),SCALAR_ZERO()),
                                  SC(-cNearZero),
                                  SC(cNearZero)),
                             VAL1(ceul2,i))));

                /* these aren't needed */
                SINDX(eul2ax, i, SCALAR_ZERO());
                SINDX(eul3ax, i, SCALAR_ZERO());
                break;

            case cUjoint:
                SINDX(eul1ax, i, 
                    NEG(DVD(ADD(SUB(MUL(INDX(VAL1(Ooiob,i),2),VAL1(seul3,i)),
                                    MUL(INDX(VAL1(Ooiob,i),1),VAL1(ceul3,i))),
                                SUB(MUL(VAL1(eul2dot,i),VAL1(eul3dot,i)),
                                    MUL(VAL1(eul1dot,i),
                                        MUL(VAL1(ceul2,i),VAL1(eul2dot,i))))),
                            QUES(NEARTO(VAL1(seul2,i),SCALAR_ZERO(),cNearZero),
                                 QUES(LESSTHAN(VAL1(seul2,i),SCALAR_ZERO()),
                                      SC(-cNearZero),
                                      SC(cNearZero)),
                                 VAL1(seul2,i)))));
                if (!IS_SIMPLE(INDX(eul1ax, i))) {
                    PRINT_ASSN1(F, PRINTNAME(eul1a), i, INDX(eul1ax,i));
                    SINDX(eul1ax, i, VREF1(eul1a, i));
                }

                SINDX(eul2ax, i,
                    SUB(ADD(MUL(INDX(VAL1(Ooiob,i),1),VAL1(seul3,i)),
                            MUL(INDX(VAL1(Ooiob,i),2),VAL1(ceul3,i))),
                        MUL(VAL1(eul1dot,i),
                            MUL(VAL1(seul2,i),VAL1(eul3dot,i)))));

                SINDX(eul3ax, i,
                    ADD(SUB(INDX(VAL1(Ooiob,i),0),
                            MUL(VAL1(eul1a,i),VAL1(ceul2,i))),
                        MUL(VAL1(eul1dot,i),
                            MUL(VAL1(seul2,i),VAL1(eul2dot,i)))));
                break;

            case c3dJoint:
            case cBearingJoint:
            case cBushingJoint:
                GIMBAL_DOTDOT(F, i, pin2x, tmp1, tmp2, tmpv1, tmpv2, 
                              tmpv3, tmpv4, tmpv5, &e1dd, &e2dd, &e3dd);
                if (!IS_CONST(e1dd)) {
                    PRINT_ASSN1(F, PRINTNAME(eul1a), i, e1dd);
                    DISPOSE_EXPR(e1dd);
                    e1dd = VREF1(eul1a, i);
                }
                if (!IS_CONST(e2dd)) {
                    PRINT_ASSN1(F, PRINTNAME(eul2a), i, e2dd);
                    DISPOSE_EXPR(e2dd);
                    e2dd = VREF1(eul2a, i);
                }
                if (!IS_CONST(e3dd)) {
                    PRINT_ASSN1(F, PRINTNAME(eul3a), i, e3dd);
                    DISPOSE_EXPR(e3dd);
                    e3dd = VREF1(eul3a, i);
                }
                SINDX(eul1ax, i, e1dd);
                SINDX(eul2ax, i, e2dd);
                SINDX(eul3ax, i, e3dd);
                break;

            case cBallJoint:
            case c6dJoint:
                SINDX(eul1ax, i, INDX(VAL1(Ooiob,i),0));
                SINDX(eul2ax, i, INDX(VAL1(Ooiob,i),1));
                SINDX(eul3ax, i, INDX(VAL1(Ooiob,i),2));
                break;

            default:
                fatal("COMPUTE_eulacc: unrecognized joint type");
                /*NOTREACHED*/
        }
    }

    ASSIGN_CLN(F, eul1a, UNUSE(eul1ax));
    ASSIGN_CLN(F, eul2a, UNUSE(eul2ax));
    ASSIGN_CLN(F, eul3a, UNUSE(eul3ax));

    /* Now handle translational accelerations. */

    sli1ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli2ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));
    sli3ax = INUSE(NEW_1dARRAY(cScalarVal,SysI.nl));

    for (i=0; i < SysI.nl; i++) {
        jk = SysI.LoopConst[i].jnt.JointKind;
        switch(jk) {
            case cWeldJoint:        
            case cPinJoint:
            case cUjoint:
            case c3dJoint:
            case cBallJoint:
                /* no translations */
                SINDX(sli1ax, i, SCALAR_ZERO());
                SINDX(sli2ax, i, SCALAR_ZERO());
                SINDX(sli3ax, i, SCALAR_ZERO());
                break;

            case cSlidingJoint: 
            case cCylJoint:
            case cBearingJoint:
                /* one translation */
                SINDX(sli1ax, i,
                    NEG(ADD(DOT(VAL1(vt19,i),VAL1(ipin,i)),
                        ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt13,i)),
                            DOT(VAL1(vt11,i),VAL1(vt25,i))))));
                SINDX(sli2ax, i, SCALAR_ZERO());
                SINDX(sli3ax, i, SCALAR_ZERO());
                break;

            case cPlanarJoint:
                /* two translations */
                SINDX(sli1ax, i,
                    NEG(ADD(DOT(VAL1(vt19,i),VAL1(iref,i)),
                        ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt2,i)),
                            DOT(VAL1(vt11,i),VAL1(vt26,i))))));
                SINDX(sli2ax, i,
                    NEG(ADD(DOT(VAL1(vt19,i),VAL1(iperp,i)),
                        ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt5,i)),
                            DOT(VAL1(vt11,i),VAL1(vt27,i))))));
                SINDX(sli3ax, i, SCALAR_ZERO());
                break;

            case c6dJoint:
            case cBushingJoint:
                /* three translations */
                SINDX(sli1ax, i,
                    NEG(ADD(DOT(VAL1(vt19,i),VAL1(ipin,i)),
                        ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt13,i)),
                            DOT(VAL1(vt11,i),VAL1(vt25,i))))));

                if (jk == c6dJoint)
                    SINDX(sli2ax, i,
                        NEG(ADD(DOT(VAL1(vt19,i),VAL1(iref,i)),
                            ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt2,i)),
                                DOT(VAL1(vt11,i),VAL1(vt26,i))))));
                else
                    SINDX(sli2ax, i,
                        NEG(ADD(DOT(VAL1(vt19,i),VAL1(ipin2,i)),
                            ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt2a,i)),
                                DOT(VAL1(vt11,i),VAL1(vt26a,i))))));

                SINDX(sli3ax, i,
                    NEG(ADD(DOT(VAL1(vt19,i),VAL1(iperp,i)),
                        ADD(DOT(MUL(SC(2.0),VAL1(vt12,i)),VAL1(vt5,i)),
                            DOT(VAL1(vt11,i),VAL1(vt27,i))))));
                break;

            default:
                fatal("COMPUTE_eulacc: unrecognized joint type");
                /*NOTREACHED*/
        }
    }

    ASSIGN_CLN(F, sli1a, UNUSE(sli1ax));
    ASSIGN_CLN(F, sli2a, UNUSE(sli2ax));
    ASSIGN_CLN(F, sli3a, UNUSE(sli3ax));
}

/* COMPUTE_lq
 *
 * Arrange all the loop joint Euler angles, Euler parameters, and 
 * sliding distances neatly into lqx.  No computation
 * is done here -- just a little shuffling.  Note that lqx here is the
 * *calculated* value of the loop q's, not the value supplied by the user
 * in sdpsstate().
 */
void COMPUTE_lq(expr lqx)
{
    int i,jn;

    if (SysI.sl == 0)
        return;                /* no loop q's or u's */

    for (i=0; i < SysI.nl; i++) {
        jn = SysI.n + i;
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cWeldJoint:        
                /* has no q's or u's */
                break;

            case cPinJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(eul1,i));
                break;

            case cUjoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(eul3,i));
                break;
                    
            case c3dJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(eul2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(eul3,i));
                break;

            case cSlidingJoint: 
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                break;

            case cCylJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(eul1,i));
                break;
                
            case cBearingJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(eul2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+3, VAL1(eul3,i));
                break;

            case cPlanarJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(sli2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(eul1,i));
                break;

            case cBallJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(eul2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(eul3,i));
                SINDX(lqx, SysI.BallQ[jn],      VAL1(eul4,i));
                break;
               
            case cBushingJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(sli2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(sli3,i));
                SINDX(lqx, SysI.FirstDOF[jn]+3, VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+4, VAL1(eul2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+5, VAL1(eul3,i));
                break;

            case c6dJoint:
                SINDX(lqx, SysI.FirstDOF[jn],   VAL1(sli1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+1, VAL1(sli2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+2, VAL1(sli3,i));
                SINDX(lqx, SysI.FirstDOF[jn]+3, VAL1(eul1,i));
                SINDX(lqx, SysI.FirstDOF[jn]+4, VAL1(eul2,i));
                SINDX(lqx, SysI.FirstDOF[jn]+5, VAL1(eul3,i));
                SINDX(lqx, SysI.BallQ[jn],      VAL1(eul4,i));
                break;

            default:
                fatal("COMPUTE_lq: unrecognized joint type");
                /*NOTREACHED*/
        }
    }
}

/* COMPUTE_lu
 *
 * Arrange all the loop joint Euler angle derivatives, Euler parameter 
 * derivatives, and sliding velocities neatly into lux.  No computation
 * is done here -- just a little shuffling.  
 */
void COMPUTE_lu(expr lux)
{
    int i,jn;

    if (SysI.sl == 0)
        return;                /* no loop q's or u's */

    for (i=0; i < SysI.nl; i++) {
        jn = SysI.n + i;
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cWeldJoint:        
                /* has no q's or u's */
                break;

            case cPinJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(eul1dot,i));
                break;

            case cUjoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(eul1dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(eul3dot,i));
                break;
                    
            case c3dJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(eul1dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(eul2dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+2, VAL1(eul3dot,i));
                break;

            case cSlidingJoint: 
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                break;

            case cCylJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(eul1dot,i));
                break;
                
            case cBearingJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(eul1dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+2, VAL1(eul2dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+3, VAL1(eul3dot,i));
                break;

            case cPlanarJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lux, SysI.FirstDOF[jn]+2, VAL1(eul1dot,i));
                break;

            case cBallJoint:
                SINDX(lux, SysI.FirstDOF[jn],   INDX(VAL1(Woiob,i),0));
                SINDX(lux, SysI.FirstDOF[jn]+1, INDX(VAL1(Woiob,i),1));
                SINDX(lux, SysI.FirstDOF[jn]+2, INDX(VAL1(Woiob,i),2));
                break;
               
            case cBushingJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lux, SysI.FirstDOF[jn]+2, VAL1(sli3v,i));
                SINDX(lux, SysI.FirstDOF[jn]+3, VAL1(eul1dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+4, VAL1(eul2dot,i));
                SINDX(lux, SysI.FirstDOF[jn]+5, VAL1(eul3dot,i));
                break;

            case c6dJoint:
                SINDX(lux, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lux, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lux, SysI.FirstDOF[jn]+2, VAL1(sli3v,i));
                SINDX(lux, SysI.FirstDOF[jn]+3, INDX(VAL1(Woiob,i),0));
                SINDX(lux, SysI.FirstDOF[jn]+4, INDX(VAL1(Woiob,i),1));
                SINDX(lux, SysI.FirstDOF[jn]+5, INDX(VAL1(Woiob,i),2));
                break;

            default:
                fatal("COMPUTE_lu: unrecognized joint type");
                /*NOTREACHED*/
        }
    }
}

/* COMPUTE_lqdot
 *
 * Arrange derivatives of loop joint Euler angles, Euler parameters, and
 * sliding distances into lqdot.  No computation is done here
 * and nothing should print out -- we're just trying to shuffle already-
 * computed variables around for convenient reference.
 */
void COMPUTE_lqdot(expr lqdotx)
{
    int i,jn;

    for (i=0; i < SysI.nl; i++) {
        jn = SysI.n + i;
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cWeldJoint:        
                /* has no qdot's */
                break;

            case cPinJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(eul1dot,i));
                break;

            case cUjoint:
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(eul3dot,i));
                break;
                    
            case c3dJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(eul2dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(eul3dot,i));
                break;

            case cSlidingJoint: 
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(sli1v,i));
                break;

            case cCylJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(sli1v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(eul1dot,i));
                break;

            case cBearingJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(eul2dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+3, VAL1(eul3dot,i));
                break;
                
            case cPlanarJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn], VAL1(sli1v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(eul1dot,i));
                break;

            case cBallJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn],   VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(eul2dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(eul3dot,i));
                SINDX(lqdotx, SysI.BallQ[jn],    VAL1(eul4dot,i));
                break;
               
            case cBushingJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(sli3v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+3, VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+4, VAL1(eul2dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+5, VAL1(eul3dot,i));
                break;

            case c6dJoint:
                SINDX(lqdotx, SysI.FirstDOF[jn],   VAL1(sli1v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+1, VAL1(sli2v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+2, VAL1(sli3v,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+3, VAL1(eul1dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+4, VAL1(eul2dot,i));
                SINDX(lqdotx, SysI.FirstDOF[jn]+5, VAL1(eul3dot,i));
                SINDX(lqdotx, SysI.BallQ[jn],    VAL1(eul4dot,i));
                break;

            default:
                fatal("COMPUTE_lqdot: unrecognized joint type");
                /*NOTREACHED*/
        }
    }
}

/* COMPUTE_ludot
 *
 * Arrange angular and/or linear accelerations at loop joints into
 * variable ludot.  No computation is done here
 * and nothing should print out -- we're just trying to shuffle already-
 * computed variables around for convenient reference.
 */
void COMPUTE_ludot(expr ludotx)
{
    int i,jn;

    for (i=0; i < SysI.nl; i++) {
        jn = SysI.n + i;
        switch(SysI.LoopConst[i].jnt.JointKind) {
            case cWeldJoint:        
                /* has no ua's */
                break;

            case cPinJoint:
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(eul1a,i));
                break;

            case cUjoint:
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(eul3a,i));
                break;
                    
            case c3dJoint:
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(eul2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(eul3a,i));
                break;

            case cSlidingJoint: 
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(sli1a,i));
                break;

            case cCylJoint:
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(sli1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(eul1a,i));
                break;

            case cBearingJoint:
                SINDX(ludotx, SysI.FirstDOF[jn],   VAL1(sli1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(eul2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+3, VAL1(eul3a,i));
                break;
                
            case cPlanarJoint:
                SINDX(ludotx, SysI.FirstDOF[jn], VAL1(sli1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(sli2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(eul1a,i));
                break;

            case cBallJoint:
                SINDX(ludotx, SysI.FirstDOF[jn],   VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(eul2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(eul3a,i));
                break;
               
            case cBushingJoint:
                SINDX(ludotx, SysI.FirstDOF[jn],   VAL1(sli1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(sli2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(sli3a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+3, VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+4, VAL1(eul2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+5, VAL1(eul3a,i));
                break;

            case c6dJoint:
                SINDX(ludotx, SysI.FirstDOF[jn],   VAL1(sli1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+1, VAL1(sli2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+2, VAL1(sli3a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+3, VAL1(eul1a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+4, VAL1(eul2a,i));
                SINDX(ludotx, SysI.FirstDOF[jn]+5, VAL1(eul3a,i));
                break;

            default:
                fatal("COMPUTE_ludot: unrecognized joint type");
                /*NOTREACHED*/
        }
    }
}
