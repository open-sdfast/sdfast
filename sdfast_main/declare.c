/* Copyright 2026 Michael Sherman
 * Copyright 1989-2025 PTC Inc.; 1984-1988 Symbolic Dynamics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "sdfast.h"
#include "sdfaprot.h"

/*
 * For typed languages, call like this
 *       declare_sdginput_vars(f, DECL_STRUCT)
 * when you want the type declared, and then
 *       declare_sdginput_vars(f, DECL_GLOBAL)
 *    or declare_sdginput_vars(f, DECL_GLOBAL|DECL_INIT)
 *    or declare_sdginput_vars(f, DECL_EXTERN)
 * when you want a variable declared using that type.
 *
 * For FORTRAN, the above calls will be ignored, and output will
 * occur only when called as
 *       declare_sdginput_vars(f, 0)
 */
void declare_sdginput_vars(FILE *F,
                      int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdginput. */
    static char *vars[] = {
        "grav", "mk", "ik", "pin", "rk", "ri", "pres", "stabvel", "stabpos", 
        "rhead", "rcom", "psrcomg", "psrcom", "mkrcomt",
        "psmk", "psik", "psrk", "psri", "psmkg", "psikg", "psrkg", "psrig",
        "mtot",
        NULL
    };

    /* These variables are present in sdginput if there are loop joints. */
    static char *lvars[] = {
        "inbpin1", "inbpin2", "inbpin3", "inbref", "bodypin", "bodyref", 
        "lbtj", "litj", "lpres", 
        "ipin", "ipin2", "iref", "iperp", "opin", "oref", "operp", "ghand",
        NULL
    };

    /* The following integer variables should follow the real variables
       in order to ensure good alignment. */
    static char *ivars[] = {
        "mfrcflg", "roustate",
        "vpkflg", "inerflg", "mmflg", "mmlduflg", "wwflg",
        "ltauflg", "fs0flg", 
        "ii",       /* Naughty variable for secure applications.          */
                    /* ii is the magic no passed to sdstate.                  */
        "mmap",
        "gravq", "mkq", "ikq", "pinq", "rkq", "riq", "presq", "stabvelq", 
        "stabposq", 
        NULL
    };
    static char *livars[] = {
        "lbtjq", "litjq", "lpresq",
        "inbpin1q", "inbpin2q", "inbpin3q", "inbrefq", "bodypinq", "bodyrefq", 
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "ginput_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal)) {
        declare_input_parms(F, decl_flags|DECL_NODSYM, &SysI);
        /* declare stuff generated by SDINIT */
        declare_vars(F, decl_flags,
          VT_INTEGER,                     "mfrcflg",
          VT_DUP,                         "roustate",
          VT_DUP,                         "vpkflg",
          VT_DUP,                         "inerflg",
          VT_DUP,                         "mmflg",
          VT_DUP,                         "mmlduflg",
          VT_DUP,                         "wwflg",
          VT_DUP,                         "ltauflg",
          VT_DUP,                         "fs0flg",
          VT_DUP,                         "ii",
          VT_USER, &SysI.type_IntArr_s,   "mmap",
          0);
        declare_vars(F, decl_flags,
          VT_USER, &SysI.type_IntVec,     "gravq",
          VT_USER, &SysI.type_IntArr_n,   "mkq",
          VT_USER, &SysI.type_IntMat_n,   "ikq",
          VT_USER, &SysI.type_IntVec_s,   "pinq",
          VT_USER, &SysI.type_IntVec_n,   "rkq",
          VT_DUP,                         "riq",
          VT_USER, &SysI.type_IntArr_s,   "presq",
          VT_USER, &SysI.type_Int,          "stabvelq",
          VT_DUP,                              "stabposq",
          0);
        if (SysI.nl)
            declare_vars(F, decl_flags,
              VT_USER, &SysI.type_IntVec_nl,       "inbpin1q",
              VT_DUP,                              "inbpin2q",
              VT_DUP,                              "inbpin3q",
              VT_DUP,                              "inbrefq",
              VT_DUP,                                    "bodypinq",
              VT_DUP,                              "bodyrefq",
              VT_DUP,                              "lbtjq",
              VT_DUP,                              "litjq",
              VT_USER, &SysI.type_IntArr_sl,       "lpresq",
              0);

        /* These must come last since they are not to be initialized. */
        declare_vars(F, decl_flags,
          VT_REAL|VT_DSYM,                          "mtot",   &mtot,
          VT_DUP|VT_DSYM,                        "psmkg",  &SysI.psmkg,
          VT_USER|VT_DSYM, &SysI.type_Vec_n,   "rhead",  &SysI.rhead,
          VT_DUP|VT_DSYM,                      "rcom",   &SysI.rcom,
          VT_USER|VT_DSYM, &SysI.type_Mat_n,   "mkrcomt",&SysI.mkrcomt,
          VT_USER|VT_DSYM, &SysI.type_Mat,     "psikg",  &SysI.psikg,
          VT_USER|VT_DSYM, &SysI.type_Vec,     "psrcomg",&SysI.psrcomg,
          VT_DUP|VT_DSYM,                      "psrkg",  &SysI.psrkg,
          VT_DUP|VT_DSYM,                      "psrig",  &SysI.psrig,
          VT_USER|VT_DSYM, &SysI.type_Arr_s,   "psmk",   &SysI.psmk,
          VT_USER|VT_DSYM, &SysI.type_Mat_s,   "psik",   &SysI.psik,
          VT_USER|VT_DSYM, &SysI.type_Vec_s,   "psrcom", &SysI.psrcom,
          VT_DUP|VT_DSYM,                      "psrk",   &SysI.psrk,
          VT_DUP|VT_DSYM,                      "psri",   &SysI.psri,
          0);

        if (SysI.nl)
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl,  "ipin",   &ipin,
              VT_DUP|VT_DSYM,                      "ipin2",  &ipin2,
              VT_DUP|VT_DSYM,                      "iref",   &iref,
              VT_DUP|VT_DSYM,                      "iperp",  &iperp,
              VT_DUP|VT_DSYM,                      "opin",   &opin,
              VT_DUP|VT_DSYM,                      "oref",   &oref,
              VT_DUP|VT_DSYM,                      "operp",  &operp,
              VT_USER|VT_DSYM, &SysI.type_Arr_nl,  "ghand",  &ghand,
              0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "ginput_t");
        if (Lang->flags & LANG_C_FAMILY) {
            do_defines(F, "ginput", vars, SysI.nl > 0, lvars);
            do_defines(F, "ginput", ivars, SysI.nl > 0, livars);
        }
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "ginput", vars, SysI.nl > 0, lvars);
        do_common(F, 1, "ginput", ivars, SysI.nl > 0, livars);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Aginput_t", "ginput",
          0);
}

void declare_sdgtopo_vars(FILE *F,
                     int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdgtopo. */
    static char *vars[] = {
        "ground", "nbod", "ndof", "ncons", "nloop", "nldof", "nloopc", "nball", 
        "nlball", "npres", "nuser", 
        "jtype", "inb", "outb", "njntdof", "njntc", "njntp", "firstq",
        "ballq", "firstm", "firstp", "trans", 
        NULL
    };

    /* These variables are present in sdgtopo if there are user constraints. */
    static char *uvars[] = {
        "firstu",
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "gtopo_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal))
    {
        declare_vars(F, decl_flags, 
          VT_INTEGER, "ground", 
          VT_DUP,     "nbod", 
          VT_DUP,     "ndof",
          VT_DUP,     "ncons",
          VT_DUP,     "nloop",
          VT_DUP,     "nldof",
          VT_DUP,     "nloopc",
          VT_DUP,     "nball",
          VT_DUP,     "nlball",
          VT_DUP,     "npres",
          VT_DUP,     "nuser",
          0);

        declare_vars(F, decl_flags, 
          VT_INTEGER|VT_ARRAY,        "jtype", SysI.nj, 0, 
          VT_DUP,                "inb",
          VT_DUP,                 "outb",
          VT_DUP,                 "njntdof",
          VT_DUP,                 "njntc",
          VT_DUP,                 "njntp",
          VT_DUP,                 "firstq",
          VT_DUP,                 "ballq",
          VT_DUP,                 "firstm",
          VT_DUP,                 "firstp",
          0);
        declare_vars(F, decl_flags, 
          VT_INTEGER|VT_ARRAY,        "trans", SysI.nh ? SysI.nh : 1, 0,
          VT_INTEGER|VT_ARRAY|VT_COND, SysI.nu, "firstu", SysI.nu, 0,
          0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "gtopo_t");
        if (Lang->flags & LANG_C_FAMILY)
            do_defines(F, "gtopo", vars, SysI.nu > 0, uvars);
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "gtopo", vars, SysI.nu > 0, uvars);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Agtopo_t", "gtopo",
          0);
}

void declare_sdgtemp_vars(FILE *F,
                     int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdgtemp. */
    static char *vars[] = {
        "temp", "tmat1", "tmat2", "tvec1", "tvec2", "tvec3", "tvec4", "tvec5",
        "tsc1", "tsc2", "tsc3",
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "gtemp_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal))
    {
        declare_vars(F, decl_flags, 
          VT_ARRAY, "temp", cMaxNumDOF, 0, 
          VT_MATRIX|VT_DSYM, "tmat1", &tmat1,
          VT_DUP|VT_DSYM,    "tmat2", &tmat2,
          VT_VECTOR|VT_DSYM, "tvec1", &tvec1,
          VT_DUP|VT_DSYM,    "tvec2", &tvec2,
          VT_DUP|VT_DSYM,    "tvec3", &tvec3,
          VT_DUP|VT_DSYM,    "tvec4", &tvec4,
          VT_DUP|VT_DSYM,    "tvec5", &tvec5,
          0);
        declare_vars(F, decl_flags, 
          VT_REAL|VT_DSYM,   "tsc1",  &tsc1,
          VT_DUP|VT_DSYM,    "tsc2",  &tsc2,
          VT_DUP|VT_DSYM,    "tsc3",  &tsc3,
          0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "gtemp_t");
        if (Lang->flags & LANG_C_FAMILY)
            do_defines(F, "gtemp", vars, 0, (char **)NULL);
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "gtemp", vars, 0, (char **)NULL);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Agtemp_t", "gtemp",
          0);
}

/*
 * These variables are generated by SDSTATE and accessed by 
 * routines called (or generated) subsequent to the generating routine.
 * They are not intended for direct
 * end-user consumption.  For example, they may contain `gaps' where
 * only those values which apply to real bodies (as opposed
 * to pseudobodies) are filled in, even though the variables are indexed
 * by pseudobody number.
 */
void declare_sdgstate_vars(FILE *F,
                      int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));
    int i,gotone;

    /* These variables are always present in sdgstate.  Note that
       we still have to add on the names for sines and cosines. */
    static char *vars[] = {
        "curtim", "q", "qn", "u", "cnk", "cnb", "rnkg", "rnk", "rnb", 
        "vnk", "vnb", "wk", "wb", "com", 
        "Cik", "Cib", "rikt", "Iko", "mkrk", "Wkk", "Vkk", "dik", 
        "rpp", "rpk", "rik", "rik2", "rpri", "Wik", "Vik", "Wirk", 
        "rkWkk", "Wkrpk", "VikWkr", "wbrcom", "perr", "verr", "aerr", "mult",
        "ufk", "utk", "utau", "mfk", "mtk", "mtau", "uacc", "uvel", "upos", 
        NULL
    };

    /* These variables are only present in sdgstate if there are loops. */
    static char *lvars[] = {
        "Cio", "Cibo", "Cibob", "ltau", "mltau", "lacc", "lvel", "lpos", "lq", 
        "mltaufi", "mltaufo", "mltauti", "mltauto", 
        "Woio", "Woiob", "Ooiob", "eul1", "eul2", "eul3", "eul4",
        "eul1dot", "eul2dot", "eul3dot", "eul4dot",
        "eul1a","eul2a","eul3a",
        "ceul1","ceul2","ceul3","seul1","seul2","seul3",
        "sli1","sli2","sli3", "sli1v","sli2v","sli3v", "sli1a","sli2a","sli3a",
        "ipin2x",
        "vt1", "vt2", "vt2a", "vt3", "vt4", "vt5", "vt6", "vt7", "vt8", "vt9", 
        "vt10", "vt10a", "vt10b", "vt10c", "vt11", "vt12", "vt13", "vt13a", 
        "vt14", "vt15", "vt16", "vt17", "vt18", "vt19", "vt20", "vt21", "vt22", 
        "vt23", "vt24", "vt25", "vt26", "vt26a", "vt27",
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "gstate_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal))
    {
        declare_vars(F, decl_flags,
          VT_REAL|VT_DSYM,                        "curtim",   &curtim,
          VT_USER|VT_DSYM, &SysI.type_Arr_nq,  "q",   &q,
          VT_DUP|VT_DSYM,                        "qn",  &qn,
          VT_USER|VT_DSYM, &SysI.type_Arr_s,   "u",   &u,
          VT_USER|VT_DSYM, &SysI.type_Mat_s,   "cnk", &cnk,
          VT_USER|VT_DSYM, &SysI.type_Mat_n,   "cnb", &cnb,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s,   "rnk", &rnk,
          VT_DUP|VT_DSYM,                           "vnk", &vnk,
          VT_DUP|VT_DSYM,                           "wk",  &wk,
          VT_USER|VT_DSYM, &SysI.type_Vec_n,   "rnb", &rnb,
          VT_DUP|VT_DSYM,                           "vnb", &vnb,
          VT_DUP|VT_DSYM,                           "wb",  &wb,
          VT_DUP|VT_DSYM,                           "wbrcom", &wbrcom,
          VT_USER|VT_DSYM, &SysI.type_Vec,     "com", &com,
          VT_DUP|VT_DSYM,                      "rnkg", &rnkg,
          0);

        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Mat_s, "Cik",  &Cik,
          VT_DUP|VT_DSYM,                      "rikt", &rikt,
          VT_DUP|VT_DSYM,                      "Iko",  &Iko,
          VT_DUP|VT_DSYM,                      "mkrk", &mkrk,
          VT_USER|VT_DSYM, &SysI.type_Mat_n, "Cib",  &Cib,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s, "Wkk", &Wkk,
          VT_DUP|VT_DSYM,               "Vkk", &Vkk,
          VT_DUP|VT_DSYM,               "dik", &dik,
          VT_DUP|VT_DSYM,               "rpp", &rpp,
          VT_DUP|VT_DSYM,               "rpk", &rpk,
          VT_DUP|VT_DSYM,               "rik", &rik,
          VT_DUP|VT_DSYM,               "rik2", &rik2,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s, "rpri", &rpri,
          VT_DUP|VT_DSYM,               "Wik", &Wik,
          VT_DUP|VT_DSYM,               "Vik", &Vik,
          VT_DUP|VT_DSYM,               "Wirk", &Wirk,
          VT_DUP|VT_DSYM,               "rkWkk", &rkWkk,
          VT_DUP|VT_DSYM,               "Wkrpk", &Wkrpk,
          VT_DUP|VT_DSYM,               "VikWkr", &VikWkr,
          0);

        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_nc, "perr", &perr,
          VT_DUP|VT_DSYM,                     "verr", &verr,
          VT_DUP|VT_DSYM,                     "aerr", &aerr,
          VT_DUP|VT_DSYM,                     "mult", &mult,
          VT_USER|VT_DSYM, &SysI.type_Vec_n,    "ufk",  &ufk,
          VT_DUP|VT_DSYM,                         "utk",  &utk,
          VT_DUP|VT_DSYM,                         "mfk",  &mfk,
          VT_DUP|VT_DSYM,                         "mtk",  &mtk,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_s,    "utau", &utau,
          VT_DUP|VT_DSYM,                         "mtau", &mtau,
          VT_DUP|VT_DSYM,                         "uacc", &uacc,
          VT_DUP|VT_DSYM,                         "uvel", &uvel,
          VT_USER|VT_DSYM, &SysI.type_Arr_nq,   "upos", &upos,
          0);

        if (SysI.nl) {
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Mat_nl, "Cio", &Cio,
              VT_DUP|VT_DSYM,                     "Cibo", &Cibo,
              VT_DUP|VT_DSYM,                     "Cibob", &Cibob,
              VT_USER|VT_DSYM, &SysI.type_Arr_nl, "eul1",  &eul1,
              VT_DUP|VT_DSYM,                     "eul2",  &eul2,
              VT_DUP|VT_DSYM,                     "eul3",  &eul3,
              VT_DUP|VT_DSYM,                     "eul4",  &eul4,
              0);

            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_nl, "eul1dot",  &eul1dot,
              VT_DUP|VT_DSYM,                     "eul2dot",  &eul2dot,
              VT_DUP|VT_DSYM,                     "eul3dot",  &eul3dot,
              VT_DUP|VT_DSYM,                     "eul4dot",  &eul4dot,
              VT_DUP|VT_DSYM,                     "eul1a",  &eul1a,
              VT_DUP|VT_DSYM,                     "eul2a",  &eul2a,
              VT_DUP|VT_DSYM,                     "eul3a",  &eul3a,
              0);

            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_nl, "ceul1",  &ceul1,
              VT_DUP|VT_DSYM,                     "ceul2",  &ceul2,
              VT_DUP|VT_DSYM,                     "ceul3",  &ceul3,
              VT_DUP|VT_DSYM,                     "seul1",  &seul1,
              VT_DUP|VT_DSYM,                     "seul2",  &seul2,
              VT_DUP|VT_DSYM,                     "seul3",  &seul3,
              VT_DUP|VT_DSYM,                     "sli1",  &sli1,
              VT_DUP|VT_DSYM,                     "sli2",  &sli2,
              VT_DUP|VT_DSYM,                     "sli3",  &sli3,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_nl, "sli1v",  &sli1v,
              VT_DUP|VT_DSYM,                     "sli2v",  &sli2v,
              VT_DUP|VT_DSYM,                     "sli3v",  &sli3v,
              VT_DUP|VT_DSYM,                     "sli1a",  &sli1a,
              VT_DUP|VT_DSYM,                     "sli2a",  &sli2a,
              VT_DUP|VT_DSYM,                     "sli3a",  &sli3a,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "ipin2x", &ipin2x,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_sl,  "ltau",   &ltau,
              VT_DUP|VT_DSYM,                            "mltau",  &mltau,
              VT_DUP|VT_DSYM,                            "lacc",   &lacc,
              VT_DUP|VT_DSYM,                            "lvel",   &lvel,
              VT_USER|VT_DSYM, &SysI.type_Arr_nlq, "lpos",   &lpos,
              VT_DUP|VT_DSYM,                            "lq",   &lq,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "mltaufi", &mltaufi,
              VT_DUP|VT_DSYM,                     "mltaufo", &mltaufo,
              VT_DUP|VT_DSYM,                     "mltauti", &mltauti,
              VT_DUP|VT_DSYM,                     "mltauto", &mltauto,
              VT_DUP|VT_DSYM,                     "Woio", &Woio,
              VT_DUP|VT_DSYM,                     "Woiob", &Woiob,
              VT_DUP|VT_DSYM,                     "Ooiob", &Ooiob,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "vt1", &vt1,
              VT_DUP|VT_DSYM,                     "vt2", &vt2,
              VT_DUP|VT_DSYM,                     "vt2a", &vt2a,
              VT_DUP|VT_DSYM,                     "vt3", &vt3,
              VT_DUP|VT_DSYM,                     "vt4", &vt4,
              VT_DUP|VT_DSYM,                     "vt5", &vt5,
              VT_DUP|VT_DSYM,                     "vt6", &vt6,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "vt7", &vt7,
              VT_DUP|VT_DSYM,                     "vt8", &vt8,
              VT_DUP|VT_DSYM,                     "vt9", &vt9,
              VT_DUP|VT_DSYM,                     "vt10", &vt10,
              VT_DUP|VT_DSYM,                     "vt10a", &vt10a,
              VT_DUP|VT_DSYM,                     "vt10b", &vt10b,
              VT_DUP|VT_DSYM,                     "vt10c", &vt10c,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "vt11", &vt11,
              VT_DUP|VT_DSYM,                     "vt12", &vt12,
              VT_DUP|VT_DSYM,                     "vt13", &vt13,
              VT_DUP|VT_DSYM,                     "vt13a", &vt13a,
              VT_DUP|VT_DSYM,                     "vt14", &vt14,
              VT_DUP|VT_DSYM,                     "vt15", &vt15,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "vt16", &vt16,
              VT_DUP|VT_DSYM,                     "vt17", &vt17,
              VT_DUP|VT_DSYM,                     "vt18", &vt18,
              VT_DUP|VT_DSYM,                     "vt19", &vt19,
              VT_DUP|VT_DSYM,                     "vt20", &vt20,
              VT_DUP|VT_DSYM,                     "vt21", &vt21,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "vt22", &vt22,
              VT_DUP|VT_DSYM,                     "vt23", &vt23,
              VT_DUP|VT_DSYM,                     "vt24", &vt24,
              VT_DUP|VT_DSYM,                     "vt25", &vt25,
              VT_DUP|VT_DSYM,                     "vt26", &vt26,
              VT_DUP|VT_DSYM,                     "vt26a", &vt26a,
              VT_DUP|VT_DSYM,                     "vt27", &vt27,
              0);
        }

        gotone = 0;
        for (i = 0; i < SysI.s; i++)
            if (SysI.PseudoBodies[i].jnt.JointKind == cPinJoint) {
                if (!gotone) {
                    declare_vars(F, decl_flags, VT_REAL, NULL, VT_PAUSE);
                    gotone = 1;
                }
                declare_vars(F, decl_flags|DECL_NUMSUFFIX, i,
                                VT_DUP, "s", VT_DUP, "c", VT_PAUSE);
            }
        if (gotone)
            declare_vars(F, decl_flags, 0); /* end incomplete declaration */
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "gstate_t");
        if (Lang->flags & LANG_C_FAMILY) {
            do_defines(F, "gstate", vars, SysI.nl > 0, lvars);
            for (i = 0; i < SysI.s; i++)
                if (SysI.PseudoBodies[i].jnt.JointKind == cPinJoint) {
                    efprintf(F,"#define s%@d (%Agstate.s%@d_)\n", i,i);
                    efprintf(F,"#define c%@d (%Agstate.c%@d_)\n", i,i);
                }
        }
    }

    if (hascommon && decllocal && Lang != &ADSIM_language)
    {
        do_common(F, 0, "gstate", vars, SysI.nl > 0, lvars);
        for (i = 0; i < SysI.s; i++)
            if (SysI.PseudoBodies[i].jnt.JointKind == cPinJoint)
                efprintf(F, ",s%@d,c%@d",i,i);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Agstate_t", "gstate",
          0);
}

/*
 * These variables are generated by SDLHS or filled in after an SDLHS call.  
 * Only mm and qdot are 
 * suitable for end-user consumption. M must appear at the beginning
 * of the struct or common block so that a brave user can look at it as
 * the `value' of sdglhs.
 */
void declare_sdglhs_vars(FILE *F,
                    int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdglhs. */
    static char *vars[] = {
        "qdot", "Otk", "Atk", "AiOiWi", "Fstar", "Tstar", "fs0", 
        "Fstark", "Tstark", "IkWk", "IkbWk", "WkIkWk", "WkIkbWk", 
        "gk", "w0w0", "w1w1", "w2w2", "w0w1", "w0w2", "w1w2",
        "w00w11", "w00w22", "w11w22", "ww", "qraux",
        NULL
    };

    /* These variables are present only if we ARE using Order(N) */
    static char *nvars[] = {
        "PH1","PH2","P11","Pd","P22",                        /*temps*/
        "L11","L21","L22","D11","D22","N11","N21","N22","HL1","HL2",
        "psi11", "psi12", "psi21", "psi22",  
        "psiD11", "psiD12", "psiD21", "psiD22",  
        "sL11", "sL21", "sL22", "sD1", "sD2", "sD1INV", "sD2INV",
        "sL11D1", "sL22D2", "sD1L21",
        "DD", "G1", "G2",                                 /*outputs*/
        NULL
    };

    /* These (big) variables are present only if we are not using Order(N) */
    static char *nnvars[] = {
        "mm", "mlo", "mdi", "IkWpk", "works", "workss", 
        NULL
    };

    /* These are present only for Kane's Formulation */
    static char *kvars[] = {
        "Wpk", "Vpk", "VWri", 
        NULL
    };

    /* These are present only if NOT Kane's Formulation */
    static char *nkvars[] = {
        "ping", "hngpt",
        NULL
    };

    /* These variables are present only if there are loop joints. */
    static char *lvars[] = {
        "ltaufk", "ltautk",
        "ltci", "ltc", "lfci", "lfc", "Tinb", "Toutb", "ltauc",
        "ltaufi", "ltaufo", "ltauti", "ltauto",
        NULL
    };

    /* The following integer variables should follow the real variables
       in order to ensure good alignment. */
    static char *ivars[] = {
        "wmap", "multmap", "jpvt", "wsiz", "wrank", 
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "glhs_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal)) {

        /* Always present */
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_s,           "fs0",    &fs0,
          VT_USER|VT_DSYM, &SysI.type_Arr_nq,          "qdot",   &qdot,
          VT_USER|VT_DSYM, &SysI.type_Vec_s,         "Otk",    &Otk,
          VT_DUP|VT_DSYM,                               "Atk",    &Atk,
          VT_DUP|VT_DSYM,                               "AiOiWi", &AiOiWi,
          VT_DUP|VT_DSYM,                               "Fstar",  &Fstar,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s,         "Tstar",  &Tstar,
          VT_DUP|VT_DSYM,                               "Fstark", &Fstark,
          VT_DUP|VT_DSYM,                               "Tstark", &Tstark,
          VT_DUP|VT_DSYM,                               "IkWk",   &IkWk,
          VT_DUP|VT_DSYM,                               "WkIkWk", &WkIkWk,
          VT_DUP|VT_DSYM,                               "gk",     &gk,
          VT_USER|VT_DSYM, &SysI.type_Vec_n,         "IkbWk",  &IkbWk,
          VT_DUP|VT_DSYM,                               "WkIkbWk", &WkIkbWk,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_n,         "w0w0",   &w0w0,
          VT_DUP|VT_DSYM,                            "w1w1",   &w1w1,
          VT_DUP|VT_DSYM,                            "w2w2",   &w2w2,
          VT_DUP|VT_DSYM,                            "w0w1",   &w0w1,
          VT_DUP|VT_DSYM,                            "w0w2",   &w0w2,
          VT_DUP|VT_DSYM,                            "w1w2",   &w1w2,
          0);

        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_n,         "w00w11", &w00w11,
          VT_DUP|VT_DSYM,                            "w00w22", &w00w22,
          VT_DUP|VT_DSYM,                            "w11w22", &w11w22,
          VT_USER,            &SysI.type_Arr_nc_nc,"ww",
          VT_USER,            &SysI.type_Arr_nc,         "qraux",
          0);

        if (sdfast_opt.formulation == OPT_ORDERN) {
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_s, "DD",  &DD,
              VT_USER|VT_DSYM, &SysI.type_Vec_s, "PH1", &PH1,
              VT_DUP|VT_DSYM,                    "PH2", &PH2,
              VT_DUP|VT_DSYM,                    "HL1", &HL1,
              VT_DUP|VT_DSYM,                    "HL2", &HL2,
              VT_DUP|VT_DSYM,                    "G1",  &G1,
              VT_DUP|VT_DSYM,                    "G2",  &G2,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Mat_s, "P11", &P11,
              VT_DUP|VT_DSYM,                    "Pd",  &Pd,
              VT_DUP|VT_DSYM,                    "P22", &P22,
              VT_DUP|VT_DSYM,                    "L11", &L11,
              VT_DUP|VT_DSYM,                    "L21", &L21,
              VT_DUP|VT_DSYM,                    "L22", &L22,
              VT_DUP|VT_DSYM,                    "D11", &D11,
              VT_DUP|VT_DSYM,                    "D22", &D22,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Mat_s, "N11", &N11,
              VT_DUP|VT_DSYM,                    "N21", &N21,
              VT_DUP|VT_DSYM,                    "N22", &N22,
              VT_DUP|VT_DSYM,                    "psi11",  &psi11,
              VT_DUP|VT_DSYM,                    "psi12",  &psi12,
              VT_DUP|VT_DSYM,                    "psi21",  &psi21,
              VT_DUP|VT_DSYM,                    "psi22",  &psi22,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Mat_s, "psiD11", &psiD11,
              VT_DUP|VT_DSYM,                    "psiD12", &psiD12,
              VT_DUP|VT_DSYM,                    "psiD21", &psiD21,
              VT_DUP|VT_DSYM,                    "psiD22", &psiD22,
              0);
            declare_vars(F, decl_flags,
              VT_MATRIX|VT_DSYM,        "sL11",   &sL11,  /* ldu temps */
              VT_DUP|VT_DSYM,                "sL21",   &sL21,
              VT_DUP|VT_DSYM,                "sL22",   &sL22,
              VT_DUP|VT_DSYM,                "sD1",    &sD1,
              VT_DUP|VT_DSYM,                "sD2",    &sD2,
              0);
            declare_vars(F, decl_flags,
              VT_MATRIX|VT_DSYM,        "sD1INV", &sD1INV,
              VT_DUP|VT_DSYM,                "sD2INV", &sD2INV,
              VT_DUP|VT_DSYM,                "sL11D1", &sL11D1,
              VT_DUP|VT_DSYM,                "sL22D2", &sL22D2,
              VT_DUP|VT_DSYM,                "sD1L21", &sD1L21,
              0);
        } else
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Arr_s_s,         "mm",    &mm, 
              VT_DUP|VT_DSYM,                                        "mlo",   &mlo, 
              VT_USER|VT_DSYM, &SysI.type_Arr_s,           "mdi",   &mdi,
                    VT_USER|VT_DSYM, &SysI.type_Vec_s_s,         "IkWpk", &IkWpk,
              VT_USER,                &SysI.type_Arr_s,          "works",
              VT_USER,                &SysI.type_Arr_s_s,        "workss",
              0);

        if (sdfast_opt.formulation == OPT_KANE) 
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_s_s,         "Wpk",   &Wpk,
              VT_DUP|VT_DSYM,                                       "Vpk",   &Vpk,
              VT_DUP|VT_DSYM,                                       "VWri",  &VWri,
              0);
        else
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_s,         "ping",  &ping,
              VT_DUP|VT_DSYM,                                       "hngpt", &hngpt,
              0);

        if (SysI.nl > 0) {
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_n,  "ltaufk",  &ltaufk,
              VT_DUP|VT_DSYM,                     "ltautk",  &ltautk,
              VT_USER|VT_DSYM, &SysI.type_Arr_sl, "ltauc",  &ltauc,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "ltci",   &ltci,
              VT_DUP|VT_DSYM,                      "ltc",    &ltc,
              VT_DUP|VT_DSYM,                           "lfci",   &lfci,
              VT_DUP|VT_DSYM,                           "lfc",    &lfc,
              0);
            declare_vars(F, decl_flags,
              VT_USER|VT_DSYM, &SysI.type_Vec_nl, "Tinb",   &Tinb,
              VT_DUP|VT_DSYM,                           "Toutb",  &Toutb,
              VT_DUP|VT_DSYM,                           "ltaufi",  &ltaufi,
              VT_DUP|VT_DSYM,                           "ltaufo",  &ltaufo,
              VT_DUP|VT_DSYM,                           "ltauti",  &ltauti,
              VT_DUP|VT_DSYM,                           "ltauto",  &ltauto,
              0);
        }

        /* These must come at the end. */
        declare_vars(F, decl_flags,
          VT_USER, &SysI.type_IntArr_nc,     "wmap",
          VT_DUP,                            "multmap",
          VT_DUP,                            "jpvt",
          VT_INTEGER,                        "wsiz",
          VT_DUP,                            "wrank",
          0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "glhs_t");
        if (Lang->flags & LANG_C_FAMILY) {
            do_defines(F, "glhs", vars, SysI.nl > 0, lvars);
            if (sdfast_opt.formulation == OPT_ORDERN)
                 do_defines(F, "glhs", nvars, 0, (char **)NULL);
            else do_defines(F, "glhs", nnvars, 0, (char **)NULL);
            if (sdfast_opt.formulation == OPT_KANE)
                 do_defines(F, "glhs", kvars, 0, (char **)NULL);
            else do_defines(F, "glhs", nkvars, 0, (char **)NULL);
            do_defines(F, "glhs", ivars, 0, (char **)NULL);
        }
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "glhs", vars, SysI.nl > 0, lvars);
        if (sdfast_opt.formulation == OPT_ORDERN)
             do_common(F, 1, "glhs", nvars, 0, (char **)NULL);
        else do_common(F, 1, "glhs", nnvars, 0, (char **)NULL);
        if (sdfast_opt.formulation == OPT_KANE)
             do_common(F, 1, "glhs", kvars, 0, (char **)NULL);
        else do_common(F, 1, "glhs", nkvars, 0, (char **)NULL);
        do_common(F, 1, "glhs", ivars, 0, (char **)NULL);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Aglhs_t", "glhs",
          0);
}

/*
 * These variables are generated by SDRHS.  Only fs and udot are 
 * suitable for end-user consumption.  Fs must appear at the beginning
 * of the struct or common block so that a brave user can look at it as
 * the `value' of sdgrhs.
 */
void declare_sdgrhs_vars(FILE *F,
                    int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdgrhs. */
    static char *vars[] = {
        "fs", "udot", "ank", "anb", "onk", "onb", "Onkb", 
        "AOnkri", "Ankb", "AnkAtk", "dyrcom",
        "ffk", "ttk", "fccikt", "ffkb", "ttkb",
        "dyad", "fc", "tc", "tauc",
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "grhs_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal)) {
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Arr_s, "fs",     &fs, 
          VT_DUP|VT_DSYM,                    "udot",   &udot,
          VT_DUP|VT_DSYM,                    "tauc",   &tauc,
          VT_USER|VT_DSYM, &SysI.type_Mat_n, "dyad",   &dyad,
          VT_USER|VT_DSYM, &SysI.type_Vec_s, "fc",     &fc,
          VT_DUP|VT_DSYM,                         "tc",     &tc,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s, "ank",    &ank,
          VT_DUP|VT_DSYM,                         "onk",    &onk,
          VT_DUP|VT_DSYM,                      "Onkb",   &Onkb,
          VT_DUP|VT_DSYM,                      "AOnkri", &AOnkri,
          VT_DUP|VT_DSYM,                      "Ankb",   &Ankb,
          VT_DUP|VT_DSYM,                      "AnkAtk", &AnkAtk,
          VT_USER|VT_DSYM, &SysI.type_Vec_n, "anb",    &anb,
          VT_DUP|VT_DSYM,                         "onb",    &onb,
          VT_DUP|VT_DSYM,                      "dyrcom", &dyrcom,
          0);
        declare_vars(F, decl_flags,
          VT_USER|VT_DSYM, &SysI.type_Vec_s, "ffk",    &ffk,
          VT_DUP|VT_DSYM,                      "ttk",    &ttk,
          VT_DUP|VT_DSYM,                      "fccikt", &fccikt,
          VT_USER|VT_DSYM, &SysI.type_Vec_n, "ffkb",   &ffkb,
          VT_DUP|VT_DSYM,                      "ttkb",   &ttkb,
          0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "grhs_t");
        if (Lang->flags & LANG_C_FAMILY)
            do_defines(F, "grhs", vars, 0, (char **)NULL);
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "grhs", vars, 0, (char **)NULL);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Agrhs_t", "grhs",
          0);
}

void declare_sdgerror_vars(FILE *F,
                      int decl_flags)
{
    int hascommon  = Lang->flags & LANG_COMMON_DECL,
        declglobex = decl_flags & (DECL_GLOBAL|DECL_EXTERN),
        declstruct = decl_flags & DECL_STRUCT,
        decllocal  = !(decl_flags & (DECL_GLOBAL|DECL_EXTERN|DECL_STRUCT));

    /* These variables are always present in sdgerror. */
    static char *vars[] = {
        "lasterr", "lastrou",
        NULL
    };

    if (!hascommon && declstruct)
        efprintf(F, Lang->struct_b, "gerror_t");
    
    if ((!hascommon && declstruct) || (hascommon && decllocal))
    {
        declare_vars(F, decl_flags, 
          VT_INTEGER, "lasterr", 
          VT_DUP,     "lastrou", 
          0);
    }

    if (!hascommon && declstruct) {
        efprintf(F, Lang->struct_e, "gerror_t");
        if (Lang->flags & LANG_C_FAMILY)
            do_defines(F, "gerror", vars, 0, (char **)0);
    }

    if (hascommon && decllocal && Lang != &ADSIM_language) {
        do_common(F, 0, "gerror", vars, 0, (char **)0);
        efprintf(F, "\n");
    }

    if (!hascommon && declglobex)
        declare_vars(F, decl_flags,
          VT_TYPENAME, "%@Agerror_t", "gerror",
          0);
}

void declare_sdldu_proc(FILE *F,
                   int decl_flags)
{
    if (!(decl_flags & DECL_FORWARD) || Lang == &Pascal_language ||
      Lang == &Ada_language)
        declare_proc(F, decl_flags, "ldu", 
          VT_USER, &SysI.type_Arr_s_s,  "m", 
          VT_DUP,                         "l",
          VT_USER, &SysI.type_Arr_s,    "d",
          0);
}

void declare_sdbsolv_proc(FILE *F,
                     int decl_flags)
{
    if (!(decl_flags & DECL_FORWARD) || Lang == &Pascal_language ||
      Lang == &Ada_language)
        declare_proc(F, decl_flags, "bsolv", 
          VT_USER, &SysI.type_Arr_s_s, "l",
          VT_USER, &SysI.type_Arr_s,   "d", 
          VT_DUP,                      "b", 
          VT_DUP,                      "x", 
          0);
}

void declare_sdsolvc_proc(FILE *F,
                     int decl_flags)
{
    if (!(decl_flags & DECL_FORWARD) || Lang == &Pascal_language ||
      Lang == &Ada_language)
        declare_proc(F, decl_flags, 
          "solvc", 
          VT_USER, &SysI.type_Arr_nc_nc, "m",
          VT_USER, &SysI.type_Arr_nc,    "b", 
          VT_DUP,                        "x", 
          0);
}

/*
 * In FORTRAN, we have to list struct variable names in a common block.
 * This routine generates `common' statements given the name of the
 * structure and a list of variable names.  If `cond' is true, we
 * add the list of conditional variable names as well.
 *
 * If `more' is true, we'll just add the current lists to the (presumably)
 * already-started common block.
 */
void do_common(FILE *F,
          int more,
          char *sname,
          char *vnames[],
          int cond,
          char *condvnames[])
{
    char *nm;

    if (more == 0)
        efprintf(F,"common/%@A%s/ ",sname);
    while(nm = *vnames++) 
        if (more)
            efprintf(F,",%s", nm);
        else {
            efprintf(F,"%s", nm);
            more = 1;
        }
    if (cond)
        while(nm = *condvnames++) 
            if (more)
                efprintf(F,",%s", nm);
            else {
                efprintf(F,"%s", nm);
                more = 1;
            }
}

/*
 * In C, we use defines to allow reference to the common block variables
 * by field names, e.g. `Cik' rather than `sdgstate.Cik_'. 
 * This routine generates `#define' statements given the name of the
 * structure and a list of variable names.  If `cond' is true, we'll
 * also generate defines for the list of conditional variable names.
 */
void do_defines(FILE *F,
           char *sname,
           char *vnames[],
           int cond,
           char *condvnames[])
{
    char *nm;
    while(nm = *vnames++) 
        efprintf(F,"#define %s (%@A%s.%s_)\n", nm, sname, nm);
    if (cond)
        while(nm = *condvnames++) 
            efprintf(F,"#define %s (%@A%s.%s_)\n", nm, sname, nm);
}
